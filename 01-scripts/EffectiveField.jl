#=
    The effective field at point i in a spin system is

                        (H_eff)_i = - dE/ds_i

    where E is the total energy of the system. Here we consider the effective
    field generated by exchange, Zeeman, Dzyaloshinskii-Moriya (only
    Bloch-type), dipolar, and perpendicular magnetic anisotropy (in z)
    interactions.

    This module contains two types of effective field functions:
        1. Ones that find the effective field at a particular point
        2. Ones that find the effective field of the entire lattice

    The functions are presented in this order in the code.

    Additionally, a few of the functions calculate the effective exchange energy
    for a lattice that contains an exchange-modifying defect.

    Useful functions:
       effectivefieldelem! computes effective field at a point
       effectivefield computes effective field of the whole lattice

    Note: effectivefieldelem! does not compute DDI field. This is because the
    DDI field must be computed for the entire lattice at once. (It's possible to
    compute element-wise DDI by executing FFT, but it would be prohibitively
    slow.) This function is only used in the field alignment algorithm, and
    there we calculate the full dipolar field every few iterations.

=#
module EffectiveField

    import Dipolar, InitialCondition, BoundaryConditions
    import DefectFunctions
    using LoopVectorization
    export effectivefieldelem!, effectivefield!, ddifield, exchangefield!,
    zeemanfield!, pmafield!, dmifield!, exchangefieldelemB!

    # effectivefieldelem! modifies a (3, 1) array to equal the effective field
    # at some point nx,ny. Prealocating this way improves speed.
    #
    # in: mat = (3, m, n) spin matrix, effField = (3, 1) arbitrary array
    # used to store answer, nx,ny = position of the spin component of interest,
    # params =  [J, H, DMI, PMA, ED, PBC, PIN, POS] material parameters,
    # defectParams = defect parameters (optional argument)
    #
    # out: nothing
    function effectivefieldelem!(effField::Array{Float64,1},
        mat::Array{Float64,3}, nx::Int, ny::Int, matParams)

        j,h,a,ed,dz,vd,bc = matParams
        pbc = bc==1.0

        # Compute exchange field
        exchangefieldelem!(effField, mat, nx, ny, j, pbc)

        if h!= 0.0 effField[3]+=h end
        if a != 0.0 dmifieldelem!(effField, mat, nx, ny, a, pbc) end
        if dz != 0.0 pmafieldelem!(effField, mat, nx, ny, dz) end
    end

    # This function modifies effField to store the exchange field of the array,
    # mat. Nearest neighbor spins are considered.
    #
    # in: mat = (3, m, n), effField = (3, 1) array used to store answer,
    # nx, ny = positions in mat to calculate exchange field, J = exchange
    # constant, pbc = periodic boundary conditions
    #
    # out: nothing
    function exchangefieldelem!(effField::Array{Float64,1},
        mat::Array{Float64,3}, nx::Int, ny::Int, J::Float64, pbc)

        p, m, n = size(mat)

        if nx > 1 && nx < m
            for k in 1:3
                effField[k] = effField[k] + J*(mat[k,nx-1,ny] + mat[k,nx+1,ny])
            end
        elseif nx==1
            if pbc
                for k in 1:3 effField[k] = effField[k] + J*mat[k,m,ny] end
            end
            for k in 1:3 effField[k] = effField[k] + J*mat[k,nx+1,ny] end
        elseif nx == m
            if pbc
                for k in 1:3 effField[k] = effField[k] + J*mat[k,1,ny] end
            end
            for k in 1:3 effField[k] = effField[k] + J*mat[k,nx-1,ny] end
        end

        if ny > 1 && ny < n
            for k in 1:3
                effField[k] = effField[k] + J*(mat[k,nx,ny-1] + mat[k,nx,ny+1])
            end
        elseif ny==1
            if pbc
                for k in 1:3 effField[k] = effField[k] + J*mat[k,nx,n] end
            end
            for k in 1:3 effField[k] = effField[k] + J*mat[k,nx,ny+1] end
        elseif ny==n
            if pbc
                for k in 1:3 effField[k] = effField[k] + J * mat[k,nx,1] end
            end
            for k in 1:3 effField[k] = effField[k] + J * mat[k,nx,ny-1] end
        end
    end

    # This function modifies effField to add the dmi contribution to the
    # effective field at some point nx, ny.
    #
    # in: mat = (3, m, n), effField = (3, 1) array used to store answer,
    # nx, ny = positions in mat to calculate exchange field, J = exchange
    # constant, pbc = periodic boundary conditions
    #
    # out: nothing
    function dmifieldelem!(effField::Array{Float64,1},
        mat::Array{Float64,3}, nx::Int, ny::Int, dmi::Float64, pbc)

        p,m,n = size(mat)

        if ny==1
            if pbc
                effField[1]-=dmi*mat[3,nx,n]
                effField[3]+=dmi*mat[1,nx,n]
            end
            effField[1]+=dmi*mat[3,nx,ny+1]
            effField[3]-=dmi*mat[1,nx,ny+1]

        elseif ny==n

            if pbc
                effField[1]+=dmi*mat[3,nx,1]
                effField[3]-=dmi*mat[1,nx,1]
            end
            effField[1]-=dmi*mat[3,nx,ny-1]
            effField[3]+=dmi*mat[1,nx,ny-1]

        else
            effField[1]+=dmi*(mat[3,nx,ny+1]-mat[3,nx,ny-1])
            effField[3]+=dmi*(mat[1,nx,ny-1]-mat[1,nx,ny+1])
        end

        if nx==1

            if pbc
                effField[2]+=dmi*mat[3,m,ny]
                effField[3]-=dmi*mat[2,m,ny]
            end
            effField[2]-=dmi*mat[3,nx+1,ny]
            effField[3]+=dmi*mat[2,nx+1,ny]

        elseif nx==m
            if pbc
                effField[2]-=dmi*mat[3,1,ny]
                effField[3]+=dmi*mat[2,1,ny]
            end
            effField[2]+=dmi*mat[3,nx-1,ny]
            effField[3]-=dmi*mat[2,nx-1,ny]
        else
            effField[2]+=dmi*(mat[3,nx-1,ny]-mat[3,nx+1,ny])
            effField[3]+=dmi*(mat[2,nx+1,ny]-mat[2,nx-1,ny])
        end

    end

    # pmafieldelem! modifies effField to include the PMA contribution at
    # point (nx, ny)
    #
    # in: mat = spin matrix, effField = effective field at some nx, ny,
    # nx & ny are coordinates of in the spin matrix, pma = anisotropy constant
    #
    # out: nothing
    function pmafieldelem!(effField::Array{Float64,1},
        mat::Array{Float64,3}, nx::Int, ny::Int, pma::Float64)

        effField[3] += pma*mat[3,nx,ny]

    end

    # Computes the effective field for the entire spin array. Returns (3, m, n)
    # array of the matrix
    #
    # in: mat = (3, m, n) spin array, params = struct of all computation
    # parameters
    #
    # out: (3, m, n) array defining effective field at every point in the
    # input array, mat
    function effectivefield!(Heff::Array{Float64,3}, mat::Array{Float64,3},
        matParams::Array{Any,1}, p)

        Heff .= 0.0 # Set initial value to zero

        j,h,a,ed,dz,v,bc = matParams
        pbc = bc==1.0

        if p.defect.t!=0.0
            jmat = p.defect.jmat
            DefectFunctions.exchangefield!(Heff, mat, jmat, bc)
        else
            exchangefield!(Heff, mat, j, bc)
        end
        if h != 0 EffectiveField.zeemanfield!(Heff, mat, h) end
        if a != 0.0 EffectiveField.dmifield!(Heff, mat, a, pbc) end
        if dz != 0.0 EffectiveField.pmafield!(Heff, mat, dz) end

        if ed != 0.0
            pp, mm, nn = size(mat)
            dipField = Array{Float64}(undef, pp, mm, nn)
            dipField = EffectiveField.ddifield(mat, ed, pbc, p.mp.v)
            Heff = Heff + dipField
        end

        # If there is a pinning field, add the field at the point where the
        # skyrmion was initially created. You can also use this to set the
        # effective field at a point to zero in order to pin a field.
        if p.pin.hPin != 0.0
            Heff[3,p.ic.px,p.ic.py] += p.pin.hPin
            # for q in 1:3 Heff[q,round(Int,p.ic.px),round(Int,p.ic.py)] = 0 end
        end

    end

    function addbc!(Heff::Array{Float64,3}, mat::Array{Float64,3},bc)

        p,m,n = size(mat)
        ll = length(bc)

        bcVal = zero(eltype(Heff))

        for j in 1:n, k in 1:p
            bcVal = 0.0
            for q in 1:ll bcVal += bc[q]*mat[k,q,j] end
            Heff[k,1,j] += bcVal

            bcVal = 0.0
            for q in 1:ll bcVal += bc[ll-q+1]*mat[k,m-ll+q,j] end
            Heff[k,m,j] += bcVal
        end

        for i in 1:m, k in 1:p
            bcVal = 0.0
            for q in 1:ll bcVal += bc[q]*mat[k,i,q] end
            Heff[k,i,1] += bcVal

            bcVal = 0.0
            for q in 1:ll bcVal += bc[ll-q+1]*mat[k,i,n-ll+q] end
            Heff[k,i,n] += bcVal
        end
    end

    # Compute the exchange field of the entire spin array, mat. Nearest neighbor
    # interactions are considered.
    #
    # in: mat = (3,m,n) spin array, params = struct of all material params,
    # Heff = (3,m,n) array of the effective field which is modified to store
    # the result
    #
    # out: nothing
    function exchangefield!(Heff::Array{Float64,3}, mat::Array{Float64,3},
        J::Float64, bc)

        p,m,n = size(mat)
        bcInt = round(Int64,bc)

        for j in 1:n, i in 1:m-1, k in 1:p
            Heff[k,i,j] += mat[k,i+1,j]
        end
        for j in 1:n, i in 2:m, k in 1:p
            Heff[k,i,j] += mat[k,i-1,j]
        end
        for j in 1:n-1, i in 1:m, k in 1:p
            Heff[k,i,j] += mat[k,i,j+1]
        end
        for j in 2:n, i in 1:m, k in 1:p
            Heff[k,i,j] += mat[k,i,j-1]
        end

        if bc==1.0
            for j in 1:n, k in 1:p
                Heff[k,m,j] += mat[k,1,j]
                Heff[k,1,j] += mat[k,m,j]
            end
            for i in 1:m, k in 1:p
                Heff[k,i,1] += mat[k,i,n]
                Heff[k,i,n] += mat[k,i,1]
            end
        elseif bc>1.0
            addbc!(Heff, mat, BoundaryConditions.extrap[bcInt])
        end
    end

    # Calculates the dmi field of the entire spin array.
    #
    # in: mat = (3,m,n) spin array, params = struct of all material params,
    # Heff = (3,m,n) array of the effective field which is modified to store
    # the result
    #
    # out: nothing
    function dmifield!(Heff::Array{Float64,3}, mat::Array{Float64,3},
        dmi::Float64, pbc)

        p,m,n = size(mat)

        for nx in 1:m, ny in 1:n

            if ny==1
                if pbc
                    Heff[1,nx,ny] = Heff[1,nx,ny] - dmi*mat[3,nx,n]
                    Heff[3,nx,ny] = Heff[3,nx,ny] + dmi*mat[1,nx,n]
                end
                Heff[1,nx,ny] = Heff[1,nx,ny] + dmi*mat[3,nx,ny+1]
                Heff[3,nx,ny] = Heff[3,nx,ny] - dmi*mat[1,nx,ny+1]
            elseif ny==n
                if pbc
                    Heff[1,nx,ny] = Heff[1,nx,ny] + dmi*mat[3,nx,1]
                    Heff[3,nx,ny] = Heff[3,nx,ny] - dmi*mat[1,nx,1]
                end
                Heff[1,nx,ny] = Heff[1,nx,ny] - dmi*mat[3,nx,ny-1]
                Heff[3,nx,ny] = Heff[3,nx,ny] + dmi*mat[1,nx,ny-1]
            else
                Heff[1,nx,ny] = Heff[1,nx,ny]+dmi*(mat[3,nx,ny+1]-mat[3,nx,ny-1])
                Heff[3,nx,ny] = Heff[3,nx,ny]+dmi*(mat[1,nx,ny-1]-mat[1,nx,ny+1])
            end

            if nx==1
                if pbc
                    Heff[2,nx,ny] = Heff[2,nx,ny] + dmi*mat[3,m,ny]
                    Heff[3,nx,ny] = Heff[3,nx,ny] - dmi*mat[2,m,ny]
                end
                Heff[2,nx,ny] = Heff[2,nx,ny] - dmi*mat[3,nx+1,ny]
                Heff[3,nx,ny] = Heff[3,nx,ny] + dmi*mat[2,nx+1,ny]

            elseif nx==m
                if pbc
                    Heff[2,nx,ny] = Heff[2,nx,ny] - dmi*mat[3,1,ny]
                    Heff[3,nx,ny] = Heff[3,nx,ny] + dmi*mat[2,1,ny]
                end
                Heff[2,nx,ny] = Heff[2,nx,ny] + dmi*mat[3,nx-1,ny]
                Heff[3,nx,ny] = Heff[3,nx,ny] - dmi*mat[2,nx-1,ny]

            else
                Heff[2,nx,ny] = Heff[2,nx,ny]+dmi*(mat[3,nx-1,ny]-mat[3,nx+1,ny])
                Heff[3,nx,ny] = Heff[3,nx,ny]+dmi*(mat[2,nx+1,ny]-mat[2,nx-1,ny])
            end

        end

    end

    # Calculates the entire Zeeman effective field
    #
    # in: mat = (3,m,n) spin array, params = struct of all material params,
    # Heff = (3,m,n) array of the effective field which is modified to store
    # the result
    #
    # out: nothing
    function zeemanfield!(Heff, mat, h)

        p, m, n = size(mat)

        for i in 1:m, j in 1:n
            Heff[3,i,j] += h
        end

    end

    # Calculates the entire PMA effective field.
    #
    # in: mat = (3,m,n) spin array, params = struct of all material params,
    # Heff = (3,m,n) array of the effective field which is modified to store
    # the result
    #
    # out: nothing
    function pmafield!(Heff::Array{Float64,3},
        mat::Array{Float64,3}, Dz)

        p, m, n = size(mat)

        for i in 1:m, j in 1:n, p in 3
            Heff[p,i,j] = Heff[p,i,j] + Dz * mat[p,i,j]
        end

    end

    # Compute the DDI field of a spin array, mat.
    #
    # in: mat = (3, m, n) array of spins, ed = DDI constant, pbc =
    # boolean defining periodic boundary conditions, phi matrices =
    # array of matrices used to compute DDI
    #
    # out: field = (3, m, n) array containing values of DDI field
    # at every point of mat.
    function ddifield(mat::Array{Float64,3}, ed::Float64, pbc::Float64,
        phiMatrices::Array{Array{Float64,2},1})

        p, m, n = size(mat)
        field = Array{Float64}(undef, p, m, n)

        field = ed * Dipolar.fhd(mat, phiMatrices, pbc)

        return field
    end

end
